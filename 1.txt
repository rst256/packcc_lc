Игнорирование результата выдаваемого функцией, подобно функциям Си, когда результат функции может быть не востребован.
Например, хочу – пишу
	a=getchar()
но могу и проигнорировать результат:
	getchar()
это в Си не будет ошибкой), то это плохой стиль. Недаром в функциональных языках игнорирование результата, выдаваемого функцией, вызывает ошибку при компиляции.


А вот это тогда какой будет стиль:

1.
	void getchar_void(){ int a = getchar(); } 
	...
	getchar_void(); /* распухание пространства имен + затраты на лишний "оберточный" вызов */

2.
	void void_call(int a){ return; } 
	...
	void_call(getchar()); /* "улучшенный" вариант №1, еще больше операций, еще более запутанный код */

3.
	int a = getchar();
	... /* a нигде далее не фигурирует и введена лишь для вызова getchar */


Ввести дополнительный аттрибут у функций определяющий допустимость  игнорирования результата ее вызова. Например аттрибут `optional` у функции - допускает игнорирование, а аттрибут `required`/`required(err_msg)` - соответственно наоборот запрещает:

	optional int getchar();
	optional("результат вызова sprintf ") int sprintf(...);
	optional("результат вызова fread ... рекомендуется выполнить проверку fread(...)==`размер ` ") int fread(...);
	required void * malloc(...);
	int strcmp(...);






Разделителей, как Вы помните, два вида: точка с запятой и перевод строки. Они равноправны. Так что при желании можно размещать несколько операторов на одной строке.